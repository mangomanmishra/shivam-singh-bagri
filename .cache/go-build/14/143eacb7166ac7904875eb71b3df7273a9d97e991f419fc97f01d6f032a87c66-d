// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/shivakantm/snapd/src/go/src/github.com/snapcore/snapd/cmd/snap-seccomp/main.go:1:1
// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2017-2019 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package main

//#cgo CFLAGS: -D_FILE_OFFSET_BITS=64
//#cgo pkg-config: libseccomp
//#cgo LDFLAGS:
//
//#include <asm/ioctls.h>
//#include <ctype.h>
//#include <errno.h>
//#include <linux/can.h>
//#include <linux/netlink.h>
//#include <sched.h>
//#include <search.h>
//#include <stdbool.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//#include <sys/prctl.h>
//#include <sys/quota.h>
//#include <sys/resource.h>
//#include <sys/socket.h>
//#include <sys/stat.h>
//#include <sys/types.h>
//#include <sys/utsname.h>
//#include <sys/ptrace.h>
//#include <termios.h>
//#include <unistd.h>
// //The XFS interface requires a 64 bit file system interface
// //but we don't want to leak this anywhere else if not globally
// //defined.
//#ifndef _FILE_OFFSET_BITS
//#define _FILE_OFFSET_BITS 64
//#include <xfs/xqm.h>
//#undef _FILE_OFFSET_BITS
//#else
//#include <xfs/xqm.h>
//#endif
//#include <seccomp.h>
//#include <linux/sched.h>
//#include <linux/seccomp.h>
//#include <arpa/inet.h>
//
//#ifndef AF_IB
//#define AF_IB 27
//#define PF_IB AF_IB
//#endif				// AF_IB
//
//#ifndef AF_MPLS
//#define AF_MPLS 28
//#define PF_MPLS AF_MPLS
//#endif				// AF_MPLS
//
// // https://github.com/sctplab/usrsctp/blob/master/usrsctplib/usrsctp.h
//#ifndef AF_CONN
//#define AF_CONN 123
//#define PF_CONN AF_CONN
//#endif				// AF_CONN
//
//#ifndef PR_CAP_AMBIENT
//#define PR_CAP_AMBIENT 47
//#define PR_CAP_AMBIENT_IS_SET    1
//#define PR_CAP_AMBIENT_RAISE     2
//#define PR_CAP_AMBIENT_LOWER     3
//#define PR_CAP_AMBIENT_CLEAR_ALL 4
//#endif				// PR_CAP_AMBIENT
//
//#ifndef PR_SET_THP_DISABLE
//#define PR_SET_THP_DISABLE 41
//#endif				// PR_SET_THP_DISABLE
//#ifndef PR_GET_THP_DISABLE
//#define PR_GET_THP_DISABLE 42
//#endif				// PR_GET_THP_DISABLE
//
//#ifndef PR_MPX_ENABLE_MANAGEMENT
//#define PR_MPX_ENABLE_MANAGEMENT 43
//#endif
//
//#ifndef PR_MPX_DISABLE_MANAGEMENT
//#define PR_MPX_DISABLE_MANAGEMENT 44
//#endif
//
// //FIXME: ARCH_BAD is defined as ~0 in libseccomp internally, however
// //       this leads to a build failure on 14.04. the important part
// //       is that its an invalid id for libseccomp.
//
//#define ARCH_BAD 0x7FFFFFFF
//#ifndef SCMP_ARCH_AARCH64
//#define SCMP_ARCH_AARCH64 ARCH_BAD
//#endif
//
//#ifndef SCMP_ARCH_PPC
//#define SCMP_ARCH_PPC ARCH_BAD
//#endif
//
//#ifndef SCMP_ARCH_PPC64LE
//#define SCMP_ARCH_PPC64LE ARCH_BAD
//#endif
//
//#ifndef SCMP_ARCH_PPC64
//#define SCMP_ARCH_PPC64 ARCH_BAD
//#endif
//
//#ifndef SCMP_ARCH_S390X
//#define SCMP_ARCH_S390X ARCH_BAD
//#endif
//
//#ifndef SECCOMP_RET_LOG
//#define SECCOMP_RET_LOG 0x7ffc0000U
//#endif
//
//typedef struct seccomp_data kernel_seccomp_data;
//
//__u32 htot32(__u32 arch, __u32 val)
//{
//	if (arch & __AUDIT_ARCH_LE)
//		return htole32(val);
//	else
//		return htobe32(val);
//}
//
//__u64 htot64(__u32 arch, __u64 val)
//{
//	if (arch & __AUDIT_ARCH_LE)
//		return htole64(val);
//	else
//		return htobe64(val);
//}
//
// /* Define missing ptrace constants. They are available on some architectures
//    only but the missing values are not reused on architectures that lack them.
//    As such we can simply define the missing pair and have a simpler cross-arch
//    code to support. */
//
// #ifndef PTRACE_GETREGS
// #define PTRACE_GETREGS 12
// #endif
// #ifndef PTRACE_SETREGS
// #define PTRACE_SETREGS 13
// #endif
// #ifndef PTRACE_GETFPREGS
// #define PTRACE_GETFPREGS 14
// #endif
// #ifndef PTRACE_SETFPREGS
// #define PTRACE_SETFPREGS 15
// #endif
// #ifndef PTRACE_GETFPXREGS
// #define PTRACE_GETFPXREGS 18
// #endif
// #ifndef PTRACE_SETFPXREGS
// #define PTRACE_SETFPXREGS 19
// #endif
import _ "unsafe"

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"syscall"

	// FIXME: we want github.com/seccomp/libseccomp-golang but that
	// will not work with trusty because libseccomp-golang checks
	// for the seccomp version and errors if it find one < 2.2.0
	"github.com/mvo5/libseccomp-golang"

	"github.com/snapcore/snapd/arch"
	"github.com/snapcore/snapd/osutil"
)

// libseccomp maximum per ARG_COUNT_MAX in src/arch.h
const ScArgsMaxlength = 6

var seccompResolver = map[string]uint64{
	// man 2 socket - domain and man 5 apparmor.d. AF_ and PF_ are
	// synonymous in the kernel and can be used interchangeably in
	// policy (ie, if use AF_UNIX, don't need a corresponding PF_UNIX
	// rule). See include/linux/socket.h
	"AF_UNIX":       syscall.AF_UNIX,
	"PF_UNIX":       ( /*line :201:19*/_Ciconst_PF_UNIX /*line :201:27*/),
	"AF_LOCAL":      syscall.AF_LOCAL,
	"PF_LOCAL":      ( /*line :203:19*/_Ciconst_PF_LOCAL /*line :203:28*/),
	"AF_INET":       syscall.AF_INET,
	"PF_INET":       ( /*line :205:19*/_Ciconst_PF_INET /*line :205:27*/),
	"AF_INET6":      syscall.AF_INET6,
	"PF_INET6":      ( /*line :207:19*/_Ciconst_PF_INET6 /*line :207:28*/),
	"AF_IPX":        syscall.AF_IPX,
	"PF_IPX":        ( /*line :209:19*/_Ciconst_PF_IPX /*line :209:26*/),
	"AF_NETLINK":    syscall.AF_NETLINK,
	"PF_NETLINK":    ( /*line :211:19*/_Ciconst_PF_NETLINK /*line :211:30*/),
	"AF_X25":        syscall.AF_X25,
	"PF_X25":        ( /*line :213:19*/_Ciconst_PF_X25 /*line :213:26*/),
	"AF_AX25":       syscall.AF_AX25,
	"PF_AX25":       ( /*line :215:19*/_Ciconst_PF_AX25 /*line :215:27*/),
	"AF_ATMPVC":     syscall.AF_ATMPVC,
	"PF_ATMPVC":     ( /*line :217:19*/_Ciconst_PF_ATMPVC /*line :217:29*/),
	"AF_APPLETALK":  syscall.AF_APPLETALK,
	"PF_APPLETALK":  ( /*line :219:19*/_Ciconst_PF_APPLETALK /*line :219:32*/),
	"AF_PACKET":     syscall.AF_PACKET,
	"PF_PACKET":     ( /*line :221:19*/_Ciconst_PF_PACKET /*line :221:29*/),
	"AF_ALG":        syscall.AF_ALG,
	"PF_ALG":        ( /*line :223:19*/_Ciconst_PF_ALG /*line :223:26*/),
	"AF_BRIDGE":     syscall.AF_BRIDGE,
	"PF_BRIDGE":     ( /*line :225:19*/_Ciconst_PF_BRIDGE /*line :225:29*/),
	"AF_NETROM":     syscall.AF_NETROM,
	"PF_NETROM":     ( /*line :227:19*/_Ciconst_PF_NETROM /*line :227:29*/),
	"AF_ROSE":       syscall.AF_ROSE,
	"PF_ROSE":       ( /*line :229:19*/_Ciconst_PF_ROSE /*line :229:27*/),
	"AF_NETBEUI":    syscall.AF_NETBEUI,
	"PF_NETBEUI":    ( /*line :231:19*/_Ciconst_PF_NETBEUI /*line :231:30*/),
	"AF_SECURITY":   syscall.AF_SECURITY,
	"PF_SECURITY":   ( /*line :233:19*/_Ciconst_PF_SECURITY /*line :233:31*/),
	"AF_KEY":        syscall.AF_KEY,
	"PF_KEY":        ( /*line :235:19*/_Ciconst_PF_KEY /*line :235:26*/),
	"AF_ASH":        syscall.AF_ASH,
	"PF_ASH":        ( /*line :237:19*/_Ciconst_PF_ASH /*line :237:26*/),
	"AF_ECONET":     syscall.AF_ECONET,
	"PF_ECONET":     ( /*line :239:19*/_Ciconst_PF_ECONET /*line :239:29*/),
	"AF_SNA":        syscall.AF_SNA,
	"PF_SNA":        ( /*line :241:19*/_Ciconst_PF_SNA /*line :241:26*/),
	"AF_IRDA":       syscall.AF_IRDA,
	"PF_IRDA":       ( /*line :243:19*/_Ciconst_PF_IRDA /*line :243:27*/),
	"AF_PPPOX":      syscall.AF_PPPOX,
	"PF_PPPOX":      ( /*line :245:19*/_Ciconst_PF_PPPOX /*line :245:28*/),
	"AF_WANPIPE":    syscall.AF_WANPIPE,
	"PF_WANPIPE":    ( /*line :247:19*/_Ciconst_PF_WANPIPE /*line :247:30*/),
	"AF_BLUETOOTH":  syscall.AF_BLUETOOTH,
	"PF_BLUETOOTH":  ( /*line :249:19*/_Ciconst_PF_BLUETOOTH /*line :249:32*/),
	"AF_RDS":        syscall.AF_RDS,
	"PF_RDS":        ( /*line :251:19*/_Ciconst_PF_RDS /*line :251:26*/),
	"AF_LLC":        syscall.AF_LLC,
	"PF_LLC":        ( /*line :253:19*/_Ciconst_PF_LLC /*line :253:26*/),
	"AF_TIPC":       syscall.AF_TIPC,
	"PF_TIPC":       ( /*line :255:19*/_Ciconst_PF_TIPC /*line :255:27*/),
	"AF_IUCV":       syscall.AF_IUCV,
	"PF_IUCV":       ( /*line :257:19*/_Ciconst_PF_IUCV /*line :257:27*/),
	"AF_RXRPC":      syscall.AF_RXRPC,
	"PF_RXRPC":      ( /*line :259:19*/_Ciconst_PF_RXRPC /*line :259:28*/),
	"AF_ISDN":       syscall.AF_ISDN,
	"PF_ISDN":       ( /*line :261:19*/_Ciconst_PF_ISDN /*line :261:27*/),
	"AF_PHONET":     syscall.AF_PHONET,
	"PF_PHONET":     ( /*line :263:19*/_Ciconst_PF_PHONET /*line :263:29*/),
	"AF_IEEE802154": syscall.AF_IEEE802154,
	"PF_IEEE802154": ( /*line :265:19*/_Ciconst_PF_IEEE802154 /*line :265:33*/),
	"AF_CAIF":       syscall.AF_CAIF,
	"PF_CAIF":       ( /*line :267:19*/_Ciconst_AF_CAIF /*line :267:27*/),
	"AF_NFC":        ( /*line :268:19*/_Ciconst_AF_NFC /*line :268:26*/),
	"PF_NFC":        ( /*line :269:19*/_Ciconst_PF_NFC /*line :269:26*/),
	"AF_VSOCK":      ( /*line :270:19*/_Ciconst_AF_VSOCK /*line :270:28*/),
	"PF_VSOCK":      ( /*line :271:19*/_Ciconst_PF_VSOCK /*line :271:28*/),
	// may not be defined in socket.h yet
	"AF_IB":   ( /*line :273:13*/_Ciconst_AF_IB /*line :273:19*/), // 27
	"PF_IB":   ( /*line :274:13*/_Ciconst_PF_IB /*line :274:19*/),
	"AF_MPLS": ( /*line :275:13*/_Ciconst_AF_MPLS /*line :275:21*/), // 28
	"PF_MPLS": ( /*line :276:13*/_Ciconst_PF_MPLS /*line :276:21*/),
	"AF_CAN":  syscall.AF_CAN,
	"PF_CAN":  ( /*line :278:13*/_Ciconst_PF_CAN /*line :278:20*/),
	"AF_CONN": ( /*line :279:13*/_Ciconst_AF_CONN /*line :279:21*/), // 123
	"PF_CONN": ( /*line :280:13*/_Ciconst_PF_CONN /*line :280:21*/),

	// man 2 socket - type
	"SOCK_STREAM":    syscall.SOCK_STREAM,
	"SOCK_DGRAM":     syscall.SOCK_DGRAM,
	"SOCK_SEQPACKET": syscall.SOCK_SEQPACKET,
	"SOCK_RAW":       syscall.SOCK_RAW,
	"SOCK_RDM":       syscall.SOCK_RDM,
	"SOCK_PACKET":    syscall.SOCK_PACKET,

	// man 2 prctl
	"PR_CAP_AMBIENT":              ( /*line :291:33*/_Ciconst_PR_CAP_AMBIENT /*line :291:48*/),
	"PR_CAP_AMBIENT_RAISE":        ( /*line :292:33*/_Ciconst_PR_CAP_AMBIENT_RAISE /*line :292:54*/),
	"PR_CAP_AMBIENT_LOWER":        ( /*line :293:33*/_Ciconst_PR_CAP_AMBIENT_LOWER /*line :293:54*/),
	"PR_CAP_AMBIENT_IS_SET":       ( /*line :294:33*/_Ciconst_PR_CAP_AMBIENT_IS_SET /*line :294:55*/),
	"PR_CAP_AMBIENT_CLEAR_ALL":    ( /*line :295:33*/_Ciconst_PR_CAP_AMBIENT_CLEAR_ALL /*line :295:58*/),
	"PR_CAPBSET_READ":             ( /*line :296:33*/_Ciconst_PR_CAPBSET_READ /*line :296:49*/),
	"PR_CAPBSET_DROP":             ( /*line :297:33*/_Ciconst_PR_CAPBSET_DROP /*line :297:49*/),
	"PR_SET_CHILD_SUBREAPER":      ( /*line :298:33*/_Ciconst_PR_SET_CHILD_SUBREAPER /*line :298:56*/),
	"PR_GET_CHILD_SUBREAPER":      ( /*line :299:33*/_Ciconst_PR_GET_CHILD_SUBREAPER /*line :299:56*/),
	"PR_SET_DUMPABLE":             ( /*line :300:33*/_Ciconst_PR_SET_DUMPABLE /*line :300:49*/),
	"PR_GET_DUMPABLE":             ( /*line :301:33*/_Ciconst_PR_GET_DUMPABLE /*line :301:49*/),
	"PR_SET_ENDIAN":               ( /*line :302:33*/_Ciconst_PR_SET_ENDIAN /*line :302:47*/),
	"PR_GET_ENDIAN":               ( /*line :303:33*/_Ciconst_PR_GET_ENDIAN /*line :303:47*/),
	"PR_SET_FPEMU":                ( /*line :304:33*/_Ciconst_PR_SET_FPEMU /*line :304:46*/),
	"PR_GET_FPEMU":                ( /*line :305:33*/_Ciconst_PR_GET_FPEMU /*line :305:46*/),
	"PR_SET_FPEXC":                ( /*line :306:33*/_Ciconst_PR_SET_FPEXC /*line :306:46*/),
	"PR_GET_FPEXC":                ( /*line :307:33*/_Ciconst_PR_GET_FPEXC /*line :307:46*/),
	"PR_SET_KEEPCAPS":             ( /*line :308:33*/_Ciconst_PR_SET_KEEPCAPS /*line :308:49*/),
	"PR_GET_KEEPCAPS":             ( /*line :309:33*/_Ciconst_PR_GET_KEEPCAPS /*line :309:49*/),
	"PR_MCE_KILL":                 ( /*line :310:33*/_Ciconst_PR_MCE_KILL /*line :310:45*/),
	"PR_MCE_KILL_GET":             ( /*line :311:33*/_Ciconst_PR_MCE_KILL_GET /*line :311:49*/),
	"PR_SET_MM":                   ( /*line :312:33*/_Ciconst_PR_SET_MM /*line :312:43*/),
	"PR_SET_MM_START_CODE":        ( /*line :313:33*/_Ciconst_PR_SET_MM_START_CODE /*line :313:54*/),
	"PR_SET_MM_END_CODE":          ( /*line :314:33*/_Ciconst_PR_SET_MM_END_CODE /*line :314:52*/),
	"PR_SET_MM_START_DATA":        ( /*line :315:33*/_Ciconst_PR_SET_MM_START_DATA /*line :315:54*/),
	"PR_SET_MM_END_DATA":          ( /*line :316:33*/_Ciconst_PR_SET_MM_END_DATA /*line :316:52*/),
	"PR_SET_MM_START_STACK":       ( /*line :317:33*/_Ciconst_PR_SET_MM_START_STACK /*line :317:55*/),
	"PR_SET_MM_START_BRK":         ( /*line :318:33*/_Ciconst_PR_SET_MM_START_BRK /*line :318:53*/),
	"PR_SET_MM_BRK":               ( /*line :319:33*/_Ciconst_PR_SET_MM_BRK /*line :319:47*/),
	"PR_SET_MM_ARG_START":         ( /*line :320:33*/_Ciconst_PR_SET_MM_ARG_START /*line :320:53*/),
	"PR_SET_MM_ARG_END":           ( /*line :321:33*/_Ciconst_PR_SET_MM_ARG_END /*line :321:51*/),
	"PR_SET_MM_ENV_START":         ( /*line :322:33*/_Ciconst_PR_SET_MM_ENV_START /*line :322:53*/),
	"PR_SET_MM_ENV_END":           ( /*line :323:33*/_Ciconst_PR_SET_MM_ENV_END /*line :323:51*/),
	"PR_SET_MM_AUXV":              ( /*line :324:33*/_Ciconst_PR_SET_MM_AUXV /*line :324:48*/),
	"PR_SET_MM_EXE_FILE":          ( /*line :325:33*/_Ciconst_PR_SET_MM_EXE_FILE /*line :325:52*/),
	"PR_MPX_ENABLE_MANAGEMENT":    ( /*line :326:33*/_Ciconst_PR_MPX_ENABLE_MANAGEMENT /*line :326:58*/),
	"PR_MPX_DISABLE_MANAGEMENT":   ( /*line :327:33*/_Ciconst_PR_MPX_DISABLE_MANAGEMENT /*line :327:59*/),
	"PR_SET_NAME":                 ( /*line :328:33*/_Ciconst_PR_SET_NAME /*line :328:45*/),
	"PR_GET_NAME":                 ( /*line :329:33*/_Ciconst_PR_GET_NAME /*line :329:45*/),
	"PR_SET_NO_NEW_PRIVS":         ( /*line :330:33*/_Ciconst_PR_SET_NO_NEW_PRIVS /*line :330:53*/),
	"PR_GET_NO_NEW_PRIVS":         ( /*line :331:33*/_Ciconst_PR_GET_NO_NEW_PRIVS /*line :331:53*/),
	"PR_SET_PDEATHSIG":            ( /*line :332:33*/_Ciconst_PR_SET_PDEATHSIG /*line :332:50*/),
	"PR_GET_PDEATHSIG":            ( /*line :333:33*/_Ciconst_PR_GET_PDEATHSIG /*line :333:50*/),
	"PR_SET_PTRACER":              ( /*line :334:33*/_Ciconst_PR_SET_PTRACER /*line :334:48*/),
	"PR_SET_SECCOMP":              ( /*line :335:33*/_Ciconst_PR_SET_SECCOMP /*line :335:48*/),
	"PR_GET_SECCOMP":              ( /*line :336:33*/_Ciconst_PR_GET_SECCOMP /*line :336:48*/),
	"PR_SET_SECUREBITS":           ( /*line :337:33*/_Ciconst_PR_SET_SECUREBITS /*line :337:51*/),
	"PR_GET_SECUREBITS":           ( /*line :338:33*/_Ciconst_PR_GET_SECUREBITS /*line :338:51*/),
	"PR_SET_THP_DISABLE":          ( /*line :339:33*/_Ciconst_PR_SET_THP_DISABLE /*line :339:52*/),
	"PR_TASK_PERF_EVENTS_DISABLE": ( /*line :340:33*/_Ciconst_PR_TASK_PERF_EVENTS_DISABLE /*line :340:61*/),
	"PR_TASK_PERF_EVENTS_ENABLE":  ( /*line :341:33*/_Ciconst_PR_TASK_PERF_EVENTS_ENABLE /*line :341:60*/),
	"PR_GET_THP_DISABLE":          ( /*line :342:33*/_Ciconst_PR_GET_THP_DISABLE /*line :342:52*/),
	"PR_GET_TID_ADDRESS":          ( /*line :343:33*/_Ciconst_PR_GET_TID_ADDRESS /*line :343:52*/),
	"PR_SET_TIMERSLACK":           ( /*line :344:33*/_Ciconst_PR_SET_TIMERSLACK /*line :344:51*/),
	"PR_GET_TIMERSLACK":           ( /*line :345:33*/_Ciconst_PR_GET_TIMERSLACK /*line :345:51*/),
	"PR_SET_TIMING":               ( /*line :346:33*/_Ciconst_PR_SET_TIMING /*line :346:47*/),
	"PR_GET_TIMING":               ( /*line :347:33*/_Ciconst_PR_GET_TIMING /*line :347:47*/),
	"PR_SET_TSC":                  ( /*line :348:33*/_Ciconst_PR_SET_TSC /*line :348:44*/),
	"PR_GET_TSC":                  ( /*line :349:33*/_Ciconst_PR_GET_TSC /*line :349:44*/),
	"PR_SET_UNALIGN":              ( /*line :350:33*/_Ciconst_PR_SET_UNALIGN /*line :350:48*/),
	"PR_GET_UNALIGN":              ( /*line :351:33*/_Ciconst_PR_GET_UNALIGN /*line :351:48*/),

	// man 2 getpriority
	"PRIO_PROCESS": syscall.PRIO_PROCESS,
	"PRIO_PGRP":    syscall.PRIO_PGRP,
	"PRIO_USER":    syscall.PRIO_USER,

	// man 2 setns
	"CLONE_NEWIPC":  syscall.CLONE_NEWIPC,
	"CLONE_NEWNET":  syscall.CLONE_NEWNET,
	"CLONE_NEWNS":   syscall.CLONE_NEWNS,
	"CLONE_NEWPID":  syscall.CLONE_NEWPID,
	"CLONE_NEWUSER": syscall.CLONE_NEWUSER,
	"CLONE_NEWUTS":  syscall.CLONE_NEWUTS,

	// man 4 tty_ioctl
	"TIOCSTI": syscall.TIOCSTI,

	// man 2 quotactl (with what Linux supports)
	"Q_SYNC":      ( /*line :370:17*/_Ciconst_Q_SYNC /*line :370:24*/),
	"Q_QUOTAON":   ( /*line :371:17*/_Ciconst_Q_QUOTAON /*line :371:27*/),
	"Q_QUOTAOFF":  ( /*line :372:17*/_Ciconst_Q_QUOTAOFF /*line :372:28*/),
	"Q_GETFMT":    ( /*line :373:17*/_Ciconst_Q_GETFMT /*line :373:26*/),
	"Q_GETINFO":   ( /*line :374:17*/_Ciconst_Q_GETINFO /*line :374:27*/),
	"Q_SETINFO":   ( /*line :375:17*/_Ciconst_Q_SETINFO /*line :375:27*/),
	"Q_GETQUOTA":  ( /*line :376:17*/_Ciconst_Q_GETQUOTA /*line :376:28*/),
	"Q_SETQUOTA":  ( /*line :377:17*/_Ciconst_Q_SETQUOTA /*line :377:28*/),
	"Q_XQUOTAON":  ( /*line :378:17*/_Ciconst_Q_XQUOTAON /*line :378:28*/),
	"Q_XQUOTAOFF": ( /*line :379:17*/_Ciconst_Q_XQUOTAOFF /*line :379:29*/),
	"Q_XGETQUOTA": ( /*line :380:17*/_Ciconst_Q_XGETQUOTA /*line :380:29*/),
	"Q_XSETQLIM":  ( /*line :381:17*/_Ciconst_Q_XSETQLIM /*line :381:28*/),
	"Q_XGETQSTAT": ( /*line :382:17*/_Ciconst_Q_XGETQSTAT /*line :382:29*/),
	"Q_XQUOTARM":  ( /*line :383:17*/_Ciconst_Q_XQUOTARM /*line :383:28*/),

	// man 2 mknod
	"S_IFREG":  syscall.S_IFREG,
	"S_IFCHR":  syscall.S_IFCHR,
	"S_IFBLK":  syscall.S_IFBLK,
	"S_IFIFO":  syscall.S_IFIFO,
	"S_IFSOCK": syscall.S_IFSOCK,

	// man 7 netlink (uapi/linux/netlink.h)
	"NETLINK_ROUTE":          syscall.NETLINK_ROUTE,
	"NETLINK_USERSOCK":       syscall.NETLINK_USERSOCK,
	"NETLINK_FIREWALL":       syscall.NETLINK_FIREWALL,
	"NETLINK_SOCK_DIAG":      ( /*line :396:28*/_Ciconst_NETLINK_SOCK_DIAG /*line :396:46*/),
	"NETLINK_NFLOG":          syscall.NETLINK_NFLOG,
	"NETLINK_XFRM":           syscall.NETLINK_XFRM,
	"NETLINK_SELINUX":        syscall.NETLINK_SELINUX,
	"NETLINK_ISCSI":          syscall.NETLINK_ISCSI,
	"NETLINK_AUDIT":          syscall.NETLINK_AUDIT,
	"NETLINK_FIB_LOOKUP":     syscall.NETLINK_FIB_LOOKUP,
	"NETLINK_CONNECTOR":      syscall.NETLINK_CONNECTOR,
	"NETLINK_NETFILTER":      syscall.NETLINK_NETFILTER,
	"NETLINK_IP6_FW":         syscall.NETLINK_IP6_FW,
	"NETLINK_DNRTMSG":        syscall.NETLINK_DNRTMSG,
	"NETLINK_KOBJECT_UEVENT": syscall.NETLINK_KOBJECT_UEVENT,
	"NETLINK_GENERIC":        syscall.NETLINK_GENERIC,
	"NETLINK_SCSITRANSPORT":  syscall.NETLINK_SCSITRANSPORT,
	"NETLINK_ECRYPTFS":       syscall.NETLINK_ECRYPTFS,
	"NETLINK_RDMA":           ( /*line :411:28*/_Ciconst_NETLINK_RDMA /*line :411:41*/),
	"NETLINK_CRYPTO":         ( /*line :412:28*/_Ciconst_NETLINK_CRYPTO /*line :412:43*/),
	"NETLINK_INET_DIAG":      ( /*line :413:28*/_Ciconst_NETLINK_INET_DIAG /*line :413:46*/), // synonymous with NETLINK_SOCK_DIAG

	// man 2 ptrace
	"PTRACE_ATTACH":     ( /*line :416:23*/_Ciconst_PTRACE_ATTACH /*line :416:37*/),
	"PTRACE_DETACH":     ( /*line :417:23*/_Ciconst_PTRACE_DETACH /*line :417:37*/),
	"PTRACE_GETREGS":    ( /*line :418:23*/_Ciconst_PTRACE_GETREGS /*line :418:38*/),
	"PTRACE_GETFPREGS":  ( /*line :419:23*/_Ciconst_PTRACE_GETFPREGS /*line :419:40*/),
	"PTRACE_GETFPXREGS": ( /*line :420:23*/_Ciconst_PTRACE_GETFPXREGS /*line :420:41*/),
	"PTRACE_GETREGSET":  ( /*line :421:23*/_Ciconst_PTRACE_GETREGSET /*line :421:40*/),
	"PTRACE_PEEKDATA":   ( /*line :422:23*/_Ciconst_PTRACE_PEEKDATA /*line :422:39*/),
	// <linux/ptrace.h> and <sys/ptrace.h> have different spellings for PEEKUS{,E}R
	"PTRACE_PEEKUSR":  ( /*line :424:21*/_Ciconst_PTRACE_PEEKUSER /*line :424:37*/),
	"PTRACE_PEEKUSER": ( /*line :425:21*/_Ciconst_PTRACE_PEEKUSER /*line :425:37*/),
	"PTRACE_CONT":     ( /*line :426:21*/_Ciconst_PTRACE_CONT /*line :426:33*/),
}

// DpkgArchToScmpArch takes a dpkg architecture and converts it to
// the seccomp.ScmpArch as used in the libseccomp-golang library
func DpkgArchToScmpArch(dpkgArch string) seccomp.ScmpArch {
	switch dpkgArch {
	case "amd64":
		return seccomp.ArchAMD64
	case "arm64":
		return seccomp.ArchARM64
	case "armhf":
		return seccomp.ArchARM
	case "i386":
		return seccomp.ArchX86
	case "powerpc":
		return seccomp.ArchPPC
	case "ppc64":
		return seccomp.ArchPPC64
	case "ppc64el":
		return seccomp.ArchPPC64LE
	case "s390x":
		return seccomp.ArchS390X
	}
	panic(fmt.Sprintf("cannot map dpkg arch %q to a seccomp arch", dpkgArch))
}

// important for unit testing
type SeccompData  /*line :454:18*/_Ctype_kernel_seccomp_data /*line :454:39*/

func (sc *SeccompData) SetNr(nr seccomp.ScmpSyscall) {
	sc.nr =  /*line :457:10*/_Ctype_int /*line :457:15*/(( /*line :457:16*/_Cfunc_htot32 /*line :457:23*/)( /*line :457:25*/_Ctype___u32 /*line :457:32*/(sc.arch),  /*line :457:43*/_Ctype___u32 /*line :457:50*/(nr)))
}
func (sc *SeccompData) SetArch(arch uint32) {
	sc.arch = ( /*line :460:12*/_Cfunc_htot32 /*line :460:19*/)( /*line :460:21*/_Ctype___u32 /*line :460:28*/(arch),  /*line :460:36*/_Ctype___u32 /*line :460:43*/(arch))
}
func (sc *SeccompData) SetArgs(args [6]uint64) {
	for i := range args {
		sc.args[i] = ( /*line :464:16*/_Cfunc_htot64 /*line :464:23*/)(sc.arch,  /*line :464:34*/_Ctype___u64 /*line :464:41*/(args[i]))
	}
}

// Only support negative args for syscalls where we understand the glibc/kernel
// prototypes and behavior. This lists all the syscalls that support negative
// arguments where we want to ignore the high 32 bits (ie, we'll mask it since
// the arg is known to be 32 bit (uid_t/gid_t) and the kernel accepts one
// or both of uint32(-1) and uint64(-1) and does its own masking).
var syscallsWithNegArgsMaskHi32 = map[string]bool{
	"chown":       true,
	"chown32":     true,
	"fchown":      true,
	"fchown32":    true,
	"fchownat":    true,
	"lchown":      true,
	"lchown32":    true,
	"setgid":      true,
	"setgid32":    true,
	"setregid":    true,
	"setregid32":  true,
	"setresgid":   true,
	"setresgid32": true,
	"setreuid":    true,
	"setreuid32":  true,
	"setresuid":   true,
	"setresuid32": true,
	"setuid":      true,
	"setuid32":    true,
}

// The kernel uses uint32 for all syscall arguments, but seccomp takes a
// uint64. For unsigned ints in our policy, just read straight into uint32
// since we don't need to worry about sign extending.
//
// For negative signed ints in our policy, we first read in as int32, convert
// to uint32 and then again uint64 to avoid sign extension woes (see
// https://github.com/seccomp/libseccomp/issues/69). For syscalls that take
// a 64bit arg that we want to express in our policy, we can add an exception
// for reading into a uint64. For now there are no exceptions, so don't need to
// do anything extra.
func readNumber(token string, syscallName string) (uint64, error) {
	if value, ok := seccompResolver[token]; ok {
		return value, nil
	}

	if value, err := strconv.ParseUint(token, 10, 32); err == nil {
		return value, nil
	}

	// Not a positive integer, see if negative is allowed for this syscall
	if !syscallsWithNegArgsMaskHi32[syscallName] {
		return 0, fmt.Errorf(`negative argument not supported with "%s"`, syscallName)
	}

	// It is, so try to parse as an int32
	value, err := strconv.ParseInt(token, 10, 32)
	if err != nil {
		return 0, err
	}

	// convert the int32 to uint32 then to uint64 (see above)
	return uint64(uint32(value)), nil
}

func parseLine(line string, secFilter *seccomp.ScmpFilter) error {
	// ignore comments and empty lines
	if strings.HasPrefix(line, "#") || line == "" {
		return nil
	}

	// regular line
	tokens := strings.Fields(line)
	if len(tokens[1:]) > ScArgsMaxlength {
		return fmt.Errorf("too many arguments specified for syscall '%s' in line %q", tokens[0], line)
	}

	// fish out syscall
	syscallName := tokens[0]
	secSyscall, err := seccomp.GetSyscallFromName(syscallName)
	if err != nil {
		// FIXME: use structed error in libseccomp-golang when
		//   https://github.com/seccomp/libseccomp-golang/pull/26
		// gets merged. For now, ignore
		// unknown syscalls
		return nil
	}

	var conds []seccomp.ScmpCondition
	for pos, arg := range tokens[1:] {
		var cmpOp seccomp.ScmpCompareOp
		var value uint64
		var err error

		if arg == "-" { // skip arg
			continue
		}

		if strings.HasPrefix(arg, ">=") {
			cmpOp = seccomp.CompareGreaterEqual
			value, err = readNumber(arg[2:], syscallName)
		} else if strings.HasPrefix(arg, "<=") {
			cmpOp = seccomp.CompareLessOrEqual
			value, err = readNumber(arg[2:], syscallName)
		} else if strings.HasPrefix(arg, "!") {
			cmpOp = seccomp.CompareNotEqual
			value, err = readNumber(arg[1:], syscallName)
		} else if strings.HasPrefix(arg, "<") {
			cmpOp = seccomp.CompareLess
			value, err = readNumber(arg[1:], syscallName)
		} else if strings.HasPrefix(arg, ">") {
			cmpOp = seccomp.CompareGreater
			value, err = readNumber(arg[1:], syscallName)
		} else if strings.HasPrefix(arg, "|") {
			cmpOp = seccomp.CompareMaskedEqual
			value, err = readNumber(arg[1:], syscallName)
		} else if strings.HasPrefix(arg, "u:") {
			cmpOp = seccomp.CompareEqual
			value, err = findUid(arg[2:])
			if err != nil {
				return fmt.Errorf("cannot parse token %q (line %q): %v", arg, line, err)
			}
		} else if strings.HasPrefix(arg, "g:") {
			cmpOp = seccomp.CompareEqual
			value, err = findGid(arg[2:])
			if err != nil {
				return fmt.Errorf("cannot parse token %q (line %q): %v", arg, line, err)
			}
		} else {
			cmpOp = seccomp.CompareEqual
			value, err = readNumber(arg, syscallName)
		}
		if err != nil {
			return fmt.Errorf("cannot parse token %q (line %q)", arg, line)
		}

		// For now only support EQ with negative args. If changing
		// this, be sure to adjust readNumber accordingly and use
		// libseccomp carefully.
		if syscallsWithNegArgsMaskHi32[syscallName] {
			if cmpOp != seccomp.CompareEqual {
				return fmt.Errorf("cannot parse token %q (line %q): unsupported comparison", arg, line)
			}
		}

		var scmpCond seccomp.ScmpCondition
		if cmpOp == seccomp.CompareMaskedEqual {
			scmpCond, err = seccomp.MakeCondition(uint(pos), cmpOp, value, value)
		} else if syscallsWithNegArgsMaskHi32[syscallName] {
			scmpCond, err = seccomp.MakeCondition(uint(pos), seccomp.CompareMaskedEqual, 0xFFFFFFFF, value)
		} else {
			scmpCond, err = seccomp.MakeCondition(uint(pos), cmpOp, value)
		}
		if err != nil {
			return fmt.Errorf("cannot parse line %q: %s", line, err)
		}
		conds = append(conds, scmpCond)
	}

	// Default to adding a precise match if possible. Otherwise
	// let seccomp figure out the architecture specifics.
	if err = secFilter.AddRuleConditionalExact(secSyscall, seccomp.ActAllow, conds); err != nil {
		err = secFilter.AddRuleConditional(secSyscall, seccomp.ActAllow, conds)
	}

	return err
}

// used to mock in tests
var (
	archDpkgArchitecture       = arch.DpkgArchitecture
	archDpkgKernelArchitecture = arch.DpkgKernelArchitecture
)

var (
	dpkgArchitecture       = archDpkgArchitecture()
	dpkgKernelArchitecture = archDpkgKernelArchitecture()
)

// For architectures that support a compat architecture, when the
// kernel and userspace match, add the compat arch, otherwise add
// the kernel arch to support the kernel's arch (eg, 64bit kernels with
// 32bit userspace).
func addSecondaryArches(secFilter *seccomp.ScmpFilter) error {
	// note that all architecture strings are in the dpkg
	// architecture notation
	var compatArch seccomp.ScmpArch

	// common case: kernel and userspace have the same arch. We
	// add a compat architecture for some architectures that
	// support it, e.g. on amd64 kernel and userland, we add
	// compat i386 syscalls.
	if dpkgArchitecture == dpkgKernelArchitecture {
		switch archDpkgArchitecture() {
		case "amd64":
			compatArch = seccomp.ArchX86
		case "arm64":
			compatArch = seccomp.ArchARM
		case "ppc64":
			compatArch = seccomp.ArchPPC
		}
	} else {
		// less common case: kernel and userspace have different archs
		// so add a compat architecture that matches the kernel. E.g.
		// an amd64 kernel with i386 userland needs the amd64 secondary
		// arch added to support specialized snaps that might
		// conditionally call 64bit code when the kernel supports it.
		// Note that in this case snapd requests i386 (or arch 'all')
		// snaps. While unusual from a traditional Linux distribution
		// perspective, certain classes of embedded devices are known
		// to use this configuration.
		compatArch = DpkgArchToScmpArch(archDpkgKernelArchitecture())
	}

	if compatArch != seccomp.ArchInvalid {
		return secFilter.AddArch(compatArch)
	}

	return nil
}

var errnoOnDenial int16 = ( /*line :685:27*/_Ciconst_EPERM /*line :685:33*/)

func preprocess(content []byte) (unrestricted, complain bool) {
	scanner := bufio.NewScanner(bytes.NewBuffer(content))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		switch line {
		case "@unrestricted":
			unrestricted = true
		case "@complain":
			complain = true
		}
	}
	return unrestricted, complain
}

// With golang-seccomp <= 0.9.0, seccomp.ActLog is not available so guess
// at the ActLog value by adding one to ActAllow and then verify that the
// string representation is what we expect for ActLog. The value and string is
// defined in https://github.com/seccomp/libseccomp-golang/pull/29.
//
// Ultimately, the fix for this workaround is to be able to use the GetApi()
// function created in the PR above. It'll tell us if the kernel, libseccomp,
// and libseccomp-golang all support ActLog, but GetApi() is also not available
// in golang-seccomp <= 0.9.0.
const actLog seccomp.ScmpAction = seccomp.ActAllow + 1

func actLogSupported() bool {
	return actLog.String() == "Action: Log system call"
}

func complainAction() seccomp.ScmpAction {
	// XXX: Work around some distributions not having a new enough
	// libseccomp-golang that declares ActLog.
	if actLogSupported() {
		return actLog
	}

	// Because ActLog is functionally ActAllow with logging, if we don't
	// support ActLog, fallback to ActLog.
	return seccomp.ActAllow
}

func compile(content []byte, out string) error {
	var err error
	var secFilter *seccomp.ScmpFilter

	unrestricted, complain := preprocess(content)
	switch {
	case unrestricted:
		return osutil.AtomicWrite(out, bytes.NewBufferString("@unrestricted\n"), 0644, 0)
	case complain:
		var complainAct seccomp.ScmpAction = complainAction()

		secFilter, err = seccomp.NewFilter(complainAct)
		if err != nil {
			if complainAct != seccomp.ActAllow {
				// ActLog is only supported in newer versions
				// of the kernel, libseccomp, and
				// libseccomp-golang. Attempt to fall back to
				// ActAllow before erroring out.
				complainAct = seccomp.ActAllow
				secFilter, err = seccomp.NewFilter(complainAct)
			}
		}

		// Set unrestricted to 'true' to fallback to the pre-ActLog
		// behavior of simply setting the allow filter without adding
		// any rules.
		if complainAct == seccomp.ActAllow {
			unrestricted = true
		}
	default:
		secFilter, err = seccomp.NewFilter(seccomp.ActErrno.SetReturnCode(errnoOnDenial))
	}
	if err != nil {
		return fmt.Errorf("cannot create seccomp filter: %s", err)
	}
	if err := addSecondaryArches(secFilter); err != nil {
		return err
	}

	if !unrestricted {
		scanner := bufio.NewScanner(bytes.NewBuffer(content))
		for scanner.Scan() {
			if err := parseLine(scanner.Text(), secFilter); err != nil {
				return fmt.Errorf("cannot parse line: %s", err)
			}
		}
		if scanner.Err(); err != nil {
			return err
		}
	}

	if osutil.GetenvBool("SNAP_SECCOMP_DEBUG") {
		secFilter.ExportPFC(os.Stdout)
	}

	// write atomically
	fout, err := osutil.NewAtomicFile(out, 0644, 0, osutil.NoChown, osutil.NoChown)
	if err != nil {
		return err
	}
	// Cancel once Committed is a NOP
	defer fout.Cancel()

	if err := secFilter.ExportBPF(fout.File); err != nil {
		return err
	}
	return fout.Commit()
}

// caches for uid and gid lookups
var uidCache = make(map[string]uint64)
var gidCache = make(map[string]uint64)

// findUid returns the identifier of the given UNIX user name.
func findUid(username string) (uint64, error) {
	if uid, ok := uidCache[username]; ok {
		return uid, nil
	}
	if !osutil.IsValidUsername(username) {
		return 0, fmt.Errorf("%q must be a valid username", username)
	}
	uid, err := osutil.FindUid(username)
	if err == nil {
		uidCache[username] = uid
	}
	return uid, err
}

// findGid returns the identifier of the given UNIX group name.
func findGid(group string) (uint64, error) {
	if gid, ok := gidCache[group]; ok {
		return gid, nil
	}
	if !osutil.IsValidUsername(group) {
		return 0, fmt.Errorf("%q must be a valid group name", group)
	}
	gid, err := osutil.FindGid(group)
	if err == nil {
		gidCache[group] = gid
	}
	return gid, err
}

func showSeccompLibraryVersion() error {
	major, minor, micro := seccomp.GetLibraryVersion()
	fmt.Fprintf(os.Stdout, "%d.%d.%d\n", major, minor, micro)
	return nil
}

func main() {
	var err error
	var content []byte

	if len(os.Args) < 2 {
		fmt.Printf("%s: need a command\n", os.Args[0])
		os.Exit(1)
	}

	cmd := os.Args[1]
	switch cmd {
	case "compile":
		if len(os.Args) < 4 {
			fmt.Println("compile needs an input and output file")
			os.Exit(1)
		}
		content, err = ioutil.ReadFile(os.Args[2])
		if err != nil {
			break
		}
		err = compile(content, os.Args[3])
	case "library-version":
		err = showSeccompLibraryVersion()
	case "version-info":
		err = showVersionInfo()
	default:
		err = fmt.Errorf("unsupported argument %q", cmd)
	}

	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}
