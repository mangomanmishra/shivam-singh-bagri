// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/shivakantm/snapd/src/go/src/github.com/snapcore/snapd/cmd/snap-update-ns/bootstrap.go:1:1
// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2017 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package main

// Use a pre-main helper to switch the mount namespace. This is required as
// golang creates threads at will and setns(..., CLONE_NEWNS) fails if any
// threads apart from the main thread exist.

/*

#include <stdlib.h>
#include "bootstrap.h"

// The bootstrap function is called by the loader before passing
// control to main. We are using `preinit_array` rather than
// `init_array` because the Go linker adds its own initialisation
// function to `init_array`, and having ours run second would defeat
// the purpose of the C bootstrap code.
//
// The `used` attribute ensures that the compiler doesn't oprimise out
// the variable on the mistaken belief that it isn't used.
__attribute__((section(".preinit_array"), used)) static typeof(&bootstrap) init = &bootstrap;

// NOTE: do not add anything before the following `import "C"'
*/
import _ "unsafe"

import (
	"errors"
	"fmt"
	"syscall"
	"unsafe"
)

var (
	// ErrNoNamespace is returned when a snap namespace does not exist.
	ErrNoNamespace = errors.New("cannot update mount namespace that was not created yet")
)

// IMPORTANT: all the code in this section may be run with elevated privileges
// when invoking snap-update-ns from the setuid snap-confine.

// BootstrapError returns error (if any) encountered in pre-main C code.
func BootstrapError() error {
	if ( /*line :62:5*/*_Cvar_bootstrap_msg /*line :62:19*/) == nil {
		return nil
	}
	errno := syscall.Errno(( /*line :65:25*/*_Cvar_bootstrap_errno /*line :65:41*/))
	// Translate EINVAL from setns or ENOENT from open into a dedicated error.
	if errno == syscall.EINVAL || errno == syscall.ENOENT {
		return ErrNoNamespace
	}
	if errno != 0 {
		return fmt.Errorf("%s: %s", ( /*line :71:31*/_Cfunc_GoString /*line :71:40*/)(( /*line :71:42*/*_Cvar_bootstrap_msg /*line :71:56*/)), errno)
	}
	return fmt.Errorf("%s", ( /*line :73:26*/_Cfunc_GoString /*line :73:35*/)(( /*line :73:37*/*_Cvar_bootstrap_msg /*line :73:51*/)))
}

// This function is here to make clearing the boostrap errors accessible
// from the tests.
func clearBootstrapError() {
	( /*line :79:2*/*_Cvar_bootstrap_msg /*line :79:16*/) = nil
	( /*line :80:2*/*_Cvar_bootstrap_errno /*line :80:18*/) = 0
}

// END IMPORTANT

func makeArgv(args []string) []* /*line :85:33*/_Ctype_char /*line :85:39*/ {
	// Create argv array with terminating NULL element
	argv := make([]* /*line :87:18*/_Ctype_char /*line :87:24*/, len(args)+1)
	for i, arg := range args {
		argv[i] = ( /*line :89:13*/_Cfunc_CString /*line :89:21*/)(arg)
	}
	return argv
}

func freeArgv(argv []* /*line :94:23*/_Ctype_char /*line :94:29*/) {
	for _, arg := range argv {
		func() { _cgo0 := /*line :96:10*/unsafe.Pointer(arg); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	}
}

// validateInstanceName checks if snap instance name is valid.
// This also sets bootstrap_msg on failure.
//
// This function is here only to make the C.validate_instance_name
// code testable from go.
func validateInstanceName(instanceName string) int {
	cStr := ( /*line :106:10*/_Cfunc_CString /*line :106:18*/)(instanceName)
	defer func() func() { _cgo0 := /*line :107:15*/unsafe.Pointer(cStr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	return int(( /*line :108:13*/_Cfunc_validate_instance_name /*line :108:36*/)(cStr))
}

// processArguments parses commnad line arguments.
// The argument cmdline is a string with embedded
// NUL bytes, separating particular arguments.
//
// This function is here only to make the C.validate_instance_name
// code testable from go.
func processArguments(args []string) (snapName string, shouldSetNs bool, processUserFstab bool, uid uint) {
	argv := makeArgv(args)
	defer freeArgv(argv)

	var snapNameOut * /*line :121:19*/_Ctype_char /*line :121:25*/
	var shouldSetNsOut  /*line :122:21*/_Ctype_bool /*line :122:27*/
	var processUserFstabOut  /*line :123:26*/_Ctype_bool /*line :123:32*/
	var uidOut  /*line :124:13*/_Ctype_ulong /*line :124:20*/
	func() { var _cgo0 _Ctype_int = _Ctype_int(len(args)); _cgoIndex1 := &/*line :125:41*/argv; _cgo1 := /*line :125:40*/&(*_cgoIndex1)[0]; _cgoBase2 := /*line :125:50*/&snapNameOut; _cgo2 := _cgoBase2; var _cgo3 *_Ctype__Bool = /*line :125:64*/&shouldSetNsOut; var _cgo4 *_Ctype__Bool = /*line :125:81*/&processUserFstabOut; var _cgo5 *_Ctype_ulong = /*line :125:103*/&uidOut; _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgoBase2, 0 == 0); _Cfunc_process_arguments(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if snapNameOut != nil {
		snapName = ( /*line :127:14*/_Cfunc_GoString /*line :127:23*/)(snapNameOut)
	}
	shouldSetNs = bool(shouldSetNsOut)
	processUserFstab = bool(processUserFstabOut)
	uid = uint(uidOut)

	return snapName, shouldSetNs, processUserFstab, uid
}
