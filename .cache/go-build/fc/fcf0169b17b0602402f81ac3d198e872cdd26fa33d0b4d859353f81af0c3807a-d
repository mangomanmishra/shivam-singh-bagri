// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/shivakantm/snapd/src/go/src/github.com/snapcore/snapd/vendor/github.com/mvo5/libseccomp-golang/seccomp_internal.go:1:1
// +build linux

// Internal functions for libseccomp Go bindings
// No exported functions

package seccomp

import (
	"fmt"
	"syscall"
)

// Unexported C wrapping code - provides the C-Golang interface
// Get the seccomp header in scope
// Need stdlib.h for free() on cstrings

// #cgo pkg-config: libseccomp
/*
#include <stdlib.h>
#include <seccomp.h>

#if SCMP_VER_MAJOR < 2
#error Minimum supported version of Libseccomp is v2.2.0
#elif SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 1
#error Minimum supported version of Libseccomp is v2.2.0
#endif

#define ARCH_BAD ~0

const uint32_t C_ARCH_BAD = ARCH_BAD;

#ifndef SCMP_ARCH_PPC
#define SCMP_ARCH_PPC ARCH_BAD
#endif

#ifndef SCMP_ARCH_PPC64
#define SCMP_ARCH_PPC64 ARCH_BAD
#endif

#ifndef SCMP_ARCH_PPC64LE
#define SCMP_ARCH_PPC64LE ARCH_BAD
#endif

#ifndef SCMP_ARCH_S390
#define SCMP_ARCH_S390 ARCH_BAD
#endif

#ifndef SCMP_ARCH_S390X
#define SCMP_ARCH_S390X ARCH_BAD
#endif

#ifndef SCMP_ARCH_AARCH64
#define SCMP_ARCH_AARCH64 ARCH_BAD
#endif

#ifndef SCMP_ARCH_MIPS
#define SCMP_ARCH_MIPS ARCH_BAD
#endif

#ifndef SCMP_ARCH_MIPS64
#define SCMP_ARCH_MIPS64 ARCH_BAD
#endif

#ifndef SCMP_ARCH_MIPS64N32
#define SCMP_ARCH_MIPS64N32 ARCH_BAD
#endif

#ifndef SCMP_ARCH_MIPSEL
#define SCMP_ARCH_MIPSEL ARCH_BAD
#endif

#ifndef SCMP_ARCH_MIPSEL64
#define SCMP_ARCH_MIPSEL64 ARCH_BAD
#endif

#ifndef SCMP_ARCH_MIPSEL64N32
#define SCMP_ARCH_MIPSEL64N32 ARCH_BAD
#endif

#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 2
#define SCMP_FLTATR_CTL_TSYNC 4
#endif

const uint32_t C_ARCH_NATIVE       = SCMP_ARCH_NATIVE;
const uint32_t C_ARCH_X86          = SCMP_ARCH_X86;
const uint32_t C_ARCH_X86_64       = SCMP_ARCH_X86_64;
const uint32_t C_ARCH_X32          = SCMP_ARCH_X32;
const uint32_t C_ARCH_ARM          = SCMP_ARCH_ARM;
const uint32_t C_ARCH_AARCH64      = SCMP_ARCH_AARCH64;
const uint32_t C_ARCH_MIPS         = SCMP_ARCH_MIPS;
const uint32_t C_ARCH_MIPS64       = SCMP_ARCH_MIPS64;
const uint32_t C_ARCH_MIPS64N32    = SCMP_ARCH_MIPS64N32;
const uint32_t C_ARCH_MIPSEL       = SCMP_ARCH_MIPSEL;
const uint32_t C_ARCH_MIPSEL64     = SCMP_ARCH_MIPSEL64;
const uint32_t C_ARCH_MIPSEL64N32  = SCMP_ARCH_MIPSEL64N32;
const uint32_t C_ARCH_PPC          = SCMP_ARCH_PPC;
const uint32_t C_ARCH_PPC64        = SCMP_ARCH_PPC64;
const uint32_t C_ARCH_PPC64LE      = SCMP_ARCH_PPC64LE;
const uint32_t C_ARCH_S390         = SCMP_ARCH_S390;
const uint32_t C_ARCH_S390X        = SCMP_ARCH_S390X;

#ifndef SCMP_ACT_LOG
#define SCMP_ACT_LOG 0x7ffc0000U
#endif

const uint32_t C_ACT_KILL          = SCMP_ACT_KILL;
const uint32_t C_ACT_TRAP          = SCMP_ACT_TRAP;
const uint32_t C_ACT_ERRNO         = SCMP_ACT_ERRNO(0);
const uint32_t C_ACT_TRACE         = SCMP_ACT_TRACE(0);
const uint32_t C_ACT_LOG           = SCMP_ACT_LOG;
const uint32_t C_ACT_ALLOW         = SCMP_ACT_ALLOW;

const uint32_t C_ATTRIBUTE_DEFAULT = (uint32_t)SCMP_FLTATR_ACT_DEFAULT;
const uint32_t C_ATTRIBUTE_BADARCH = (uint32_t)SCMP_FLTATR_ACT_BADARCH;
const uint32_t C_ATTRIBUTE_NNP     = (uint32_t)SCMP_FLTATR_CTL_NNP;
const uint32_t C_ATTRIBUTE_TSYNC   = (uint32_t)SCMP_FLTATR_CTL_TSYNC;

const int      C_CMP_NE            = (int)SCMP_CMP_NE;
const int      C_CMP_LT            = (int)SCMP_CMP_LT;
const int      C_CMP_LE            = (int)SCMP_CMP_LE;
const int      C_CMP_EQ            = (int)SCMP_CMP_EQ;
const int      C_CMP_GE            = (int)SCMP_CMP_GE;
const int      C_CMP_GT            = (int)SCMP_CMP_GT;
const int      C_CMP_MASKED_EQ     = (int)SCMP_CMP_MASKED_EQ;

const int      C_VERSION_MAJOR     = SCMP_VER_MAJOR;
const int      C_VERSION_MINOR     = SCMP_VER_MINOR;
const int      C_VERSION_MICRO     = SCMP_VER_MICRO;

#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR >= 3
unsigned int get_major_version()
{
        return seccomp_version()->major;
}

unsigned int get_minor_version()
{
        return seccomp_version()->minor;
}

unsigned int get_micro_version()
{
        return seccomp_version()->micro;
}
#else
unsigned int get_major_version()
{
        return (unsigned int)C_VERSION_MAJOR;
}

unsigned int get_minor_version()
{
        return (unsigned int)C_VERSION_MINOR;
}

unsigned int get_micro_version()
{
        return (unsigned int)C_VERSION_MICRO;
}
#endif

typedef struct scmp_arg_cmp* scmp_cast_t;

void* make_arg_cmp_array(unsigned int length)
{
        return calloc(length, sizeof(struct scmp_arg_cmp));
}

// Wrapper to add an scmp_arg_cmp struct to an existing arg_cmp array
void add_struct_arg_cmp(
                        struct scmp_arg_cmp* arr,
                        unsigned int pos,
                        unsigned int arg,
                        int compare,
                        uint64_t a,
                        uint64_t b
                       )
{
        arr[pos].arg = arg;
        arr[pos].op = compare;
        arr[pos].datum_a = a;
        arr[pos].datum_b = b;

        return;
}
*/
import _ "unsafe"

// Nonexported types
type scmpFilterAttr uint32

// Nonexported constants

const (
	filterAttrActDefault scmpFilterAttr = iota
	filterAttrActBadArch scmpFilterAttr = iota
	filterAttrNNP        scmpFilterAttr = iota
	filterAttrTsync      scmpFilterAttr = iota
)

const (
	// An error return from certain libseccomp functions
	scmpError  /*line :203:12*/_Ctype_int /*line :203:17*/ = -1
	// Comparison boundaries to check for architecture validity
	archStart ScmpArch = ArchNative
	archEnd   ScmpArch = ArchS390X
	// Comparison boundaries to check for action validity
	actionStart ScmpAction = ActKill
	actionEnd   ScmpAction = ActLog
	// Comparison boundaries to check for comparison operator validity
	compareOpStart ScmpCompareOp = CompareNotEqual
	compareOpEnd   ScmpCompareOp = CompareMaskedEqual
)

var (
	// Error thrown on bad filter context
	errBadFilter = fmt.Errorf("filter is invalid or uninitialized")
	// Constants representing library major, minor, and micro versions
	verMajor = uint(( /*line :219:18*/_Cfunc_get_major_version /*line :219:36*/)())
	verMinor = uint(( /*line :220:18*/_Cfunc_get_minor_version /*line :220:36*/)())
	verMicro = uint(( /*line :221:18*/_Cfunc_get_micro_version /*line :221:36*/)())
)

// Nonexported functions

// Check if library version is greater than or equal to the given one
func checkVersionAbove(major, minor, micro uint) bool {
	return (verMajor > major) ||
		(verMajor == major && verMinor > minor) ||
		(verMajor == major && verMinor == minor && verMicro >= micro)
}

// Ensure that the library is supported, i.e. >= 2.1.0.
func ensureSupportedVersion() error {
	if !checkVersionAbove(2, 1, 0) {
		return VersionError{}
	}
	return nil
}

// Filter helpers

// Filter finalizer - ensure that kernel context for filters is freed
func filterFinalizer(f *ScmpFilter) {
	f.Release()
}

// Get a raw filter attribute
func (f *ScmpFilter) getFilterAttr(attr scmpFilterAttr) ( /*line :249:58*/_Ctype_uint32_t /*line :249:68*/, error) {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return 0x0, errBadFilter
	}

	var attribute  /*line :257:16*/_Ctype_uint32_t /*line :257:26*/

	retCode := func() _Ctype_int{ _cgo0 := /*line :259:32*/f.filterCtx; var _cgo1 uint32 = /*line :259:45*/attr.toNative(); var _cgo2 *_Ctype_uint32_t = /*line :259:62*/&attribute; _cgoCheckPointer(_cgo0, nil); return _Cfunc_seccomp_attr_get(_cgo0, _cgo1, _cgo2); }()
	if retCode != 0 {
		return 0x0, syscall.Errno(-1 * retCode)
	}

	return attribute, nil
}

// Set a raw filter attribute
func (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value  /*line :268:63*/_Ctype_uint32_t /*line :268:73*/) error {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return errBadFilter
	}

	retCode := func() _Ctype_int{ _cgo0 := /*line :276:32*/f.filterCtx; var _cgo1 uint32 = /*line :276:45*/attr.toNative(); var _cgo2 _Ctype_uint32_t = /*line :276:62*/value; _cgoCheckPointer(_cgo0, nil); return _Cfunc_seccomp_attr_set(_cgo0, _cgo1, _cgo2); }()
	if retCode != 0 {
		return syscall.Errno(-1 * retCode)
	}

	return nil
}

// DOES NOT LOCK OR CHECK VALIDITY
// Assumes caller has already done this
// Wrapper for seccomp_rule_add_... functions
func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, length  /*line :287:93*/_Ctype_uint /*line :287:99*/, cond  /*line :287:106*/_Ctype_scmp_cast_t /*line :287:119*/) error {
	if length != 0 && cond == nil {
		return fmt.Errorf("null conditions list, but length is nonzero")
	}

	var retCode  /*line :292:14*/_Ctype_int /*line :292:19*/
	if exact {
		retCode = func() _Ctype_int{ _cgo0 := /*line :294:44*/f.filterCtx; var _cgo1 _Ctype_uint32_t = /*line :294:57*/action.toNative(); var _cgo2 _Ctype_int = _Ctype_int(call); var _cgo3 _Ctype_uint = /*line :294:89*/length; var _cgo4 *_Ctype_struct_scmp_arg_cmp = /*line :294:97*/cond; _cgoCheckPointer(_cgo0, nil); return _Cfunc_seccomp_rule_add_exact_array(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	} else {
		retCode = func() _Ctype_int{ _cgo0 := /*line :296:38*/f.filterCtx; var _cgo1 _Ctype_uint32_t = /*line :296:51*/action.toNative(); var _cgo2 _Ctype_int = _Ctype_int(call); var _cgo3 _Ctype_uint = /*line :296:83*/length; var _cgo4 *_Ctype_struct_scmp_arg_cmp = /*line :296:91*/cond; _cgoCheckPointer(_cgo0, nil); return _Cfunc_seccomp_rule_add_array(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	}

	if syscall.Errno(-1*retCode) == syscall.EFAULT {
		return fmt.Errorf("unrecognized syscall")
	} else if syscall.Errno(-1*retCode) == syscall.EPERM {
		return fmt.Errorf("requested action matches default action of filter")
	} else if syscall.Errno(-1*retCode) == syscall.EINVAL {
		return fmt.Errorf("two checks on same syscall argument")
	} else if retCode != 0 {
		return syscall.Errno(-1 * retCode)
	}

	return nil
}

// Generic add function for filter rules
func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return errBadFilter
	}

	if len(conds) == 0 {
		if err := f.addRuleWrapper(call, action, exact, 0, nil); err != nil {
			return err
		}
	} else {
		// We don't support conditional filtering in library version v2.1
		if !checkVersionAbove(2, 1, 1) {
			return VersionError{
				message: "conditional filtering is not supported",
				minimum: "2.2.1",
			}
		}

		argsArr := ( /*line :334:14*/_Cfunc_make_arg_cmp_array /*line :334:33*/)( /*line :334:35*/_Ctype_uint /*line :334:41*/(len(conds)))
		if argsArr == nil {
			return fmt.Errorf("error allocating memory for conditions")
		}
		defer func() func() { _cgo0 := /*line :338:16*/argsArr; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()

		for i, cond := range conds {
			( /*line :341:4*/_Cfunc_add_struct_arg_cmp /*line :341:23*/)( /*line :341:25*/_Ctype_scmp_cast_t /*line :341:38*/(argsArr),  /*line :341:49*/_Ctype_uint /*line :341:55*/(i),
				 /*line :342:5*/_Ctype_uint /*line :342:11*/(cond.Argument), cond.Op.toNative(),
				 /*line :343:5*/_Ctype_uint64_t /*line :343:15*/(cond.Operand1),  /*line :343:32*/_Ctype_uint64_t /*line :343:42*/(cond.Operand2))
		}

		if err := f.addRuleWrapper(call, action, exact,  /*line :346:51*/_Ctype_uint /*line :346:57*/(len(conds)),  /*line :346:71*/_Ctype_scmp_cast_t /*line :346:84*/(argsArr)); err != nil {
			return err
		}
	}

	return nil
}

// Generic Helpers

// Helper - Sanitize Arch token input
func sanitizeArch(in ScmpArch) error {
	if in < archStart || in > archEnd {
		return fmt.Errorf("unrecognized architecture")
	}

	if in.toNative() == ( /*line :362:22*/*_Cvar_C_ARCH_BAD /*line :362:33*/) {
		return fmt.Errorf("architecture is not supported on this version of the library")
	}

	return nil
}

func sanitizeAction(in ScmpAction) error {
	inTmp := in & 0x0000FFFF
	if inTmp < actionStart || inTmp > actionEnd {
		return fmt.Errorf("unrecognized action")
	}

	if inTmp != ActTrace && inTmp != ActErrno && (in&0xFFFF0000) != 0 {
		return fmt.Errorf("highest 16 bits must be zeroed except for Trace and Errno")
	}

	return nil
}

func sanitizeCompareOp(in ScmpCompareOp) error {
	if in < compareOpStart || in > compareOpEnd {
		return fmt.Errorf("unrecognized comparison operator")
	}

	return nil
}

func archFromNative(a  /*line :390:23*/_Ctype_uint32_t /*line :390:33*/) (ScmpArch, error) {
	switch a {
	case ( /*line :392:7*/*_Cvar_C_ARCH_X86 /*line :392:18*/):
		return ArchX86, nil
	case ( /*line :394:7*/*_Cvar_C_ARCH_X86_64 /*line :394:21*/):
		return ArchAMD64, nil
	case ( /*line :396:7*/*_Cvar_C_ARCH_X32 /*line :396:18*/):
		return ArchX32, nil
	case ( /*line :398:7*/*_Cvar_C_ARCH_ARM /*line :398:18*/):
		return ArchARM, nil
	case ( /*line :400:7*/*_Cvar_C_ARCH_NATIVE /*line :400:21*/):
		return ArchNative, nil
	case ( /*line :402:7*/*_Cvar_C_ARCH_AARCH64 /*line :402:22*/):
		return ArchARM64, nil
	case ( /*line :404:7*/*_Cvar_C_ARCH_MIPS /*line :404:19*/):
		return ArchMIPS, nil
	case ( /*line :406:7*/*_Cvar_C_ARCH_MIPS64 /*line :406:21*/):
		return ArchMIPS64, nil
	case ( /*line :408:7*/*_Cvar_C_ARCH_MIPS64N32 /*line :408:24*/):
		return ArchMIPS64N32, nil
	case ( /*line :410:7*/*_Cvar_C_ARCH_MIPSEL /*line :410:21*/):
		return ArchMIPSEL, nil
	case ( /*line :412:7*/*_Cvar_C_ARCH_MIPSEL64 /*line :412:23*/):
		return ArchMIPSEL64, nil
	case ( /*line :414:7*/*_Cvar_C_ARCH_MIPSEL64N32 /*line :414:26*/):
		return ArchMIPSEL64N32, nil
	case ( /*line :416:7*/*_Cvar_C_ARCH_PPC /*line :416:18*/):
		return ArchPPC, nil
	case ( /*line :418:7*/*_Cvar_C_ARCH_PPC64 /*line :418:20*/):
		return ArchPPC64, nil
	case ( /*line :420:7*/*_Cvar_C_ARCH_PPC64LE /*line :420:22*/):
		return ArchPPC64LE, nil
	case ( /*line :422:7*/*_Cvar_C_ARCH_S390 /*line :422:19*/):
		return ArchS390, nil
	case ( /*line :424:7*/*_Cvar_C_ARCH_S390X /*line :424:20*/):
		return ArchS390X, nil
	default:
		return 0x0, fmt.Errorf("unrecognized architecture")
	}
}

// Only use with sanitized arches, no error handling
func (a ScmpArch) toNative()  /*line :432:30*/_Ctype_uint32_t /*line :432:40*/ {
	switch a {
	case ArchX86:
		return ( /*line :435:10*/*_Cvar_C_ARCH_X86 /*line :435:21*/)
	case ArchAMD64:
		return ( /*line :437:10*/*_Cvar_C_ARCH_X86_64 /*line :437:24*/)
	case ArchX32:
		return ( /*line :439:10*/*_Cvar_C_ARCH_X32 /*line :439:21*/)
	case ArchARM:
		return ( /*line :441:10*/*_Cvar_C_ARCH_ARM /*line :441:21*/)
	case ArchARM64:
		return ( /*line :443:10*/*_Cvar_C_ARCH_AARCH64 /*line :443:25*/)
	case ArchMIPS:
		return ( /*line :445:10*/*_Cvar_C_ARCH_MIPS /*line :445:22*/)
	case ArchMIPS64:
		return ( /*line :447:10*/*_Cvar_C_ARCH_MIPS64 /*line :447:24*/)
	case ArchMIPS64N32:
		return ( /*line :449:10*/*_Cvar_C_ARCH_MIPS64N32 /*line :449:27*/)
	case ArchMIPSEL:
		return ( /*line :451:10*/*_Cvar_C_ARCH_MIPSEL /*line :451:24*/)
	case ArchMIPSEL64:
		return ( /*line :453:10*/*_Cvar_C_ARCH_MIPSEL64 /*line :453:26*/)
	case ArchMIPSEL64N32:
		return ( /*line :455:10*/*_Cvar_C_ARCH_MIPSEL64N32 /*line :455:29*/)
	case ArchPPC:
		return ( /*line :457:10*/*_Cvar_C_ARCH_PPC /*line :457:21*/)
	case ArchPPC64:
		return ( /*line :459:10*/*_Cvar_C_ARCH_PPC64 /*line :459:23*/)
	case ArchPPC64LE:
		return ( /*line :461:10*/*_Cvar_C_ARCH_PPC64LE /*line :461:25*/)
	case ArchS390:
		return ( /*line :463:10*/*_Cvar_C_ARCH_S390 /*line :463:22*/)
	case ArchS390X:
		return ( /*line :465:10*/*_Cvar_C_ARCH_S390X /*line :465:23*/)
	case ArchNative:
		return ( /*line :467:10*/*_Cvar_C_ARCH_NATIVE /*line :467:24*/)
	default:
		return 0x0
	}
}

// Only use with sanitized ops, no error handling
func (a ScmpCompareOp) toNative()  /*line :474:35*/_Ctype_int /*line :474:40*/ {
	switch a {
	case CompareNotEqual:
		return ( /*line :477:10*/*_Cvar_C_CMP_NE /*line :477:19*/)
	case CompareLess:
		return ( /*line :479:10*/*_Cvar_C_CMP_LT /*line :479:19*/)
	case CompareLessOrEqual:
		return ( /*line :481:10*/*_Cvar_C_CMP_LE /*line :481:19*/)
	case CompareEqual:
		return ( /*line :483:10*/*_Cvar_C_CMP_EQ /*line :483:19*/)
	case CompareGreaterEqual:
		return ( /*line :485:10*/*_Cvar_C_CMP_GE /*line :485:19*/)
	case CompareGreater:
		return ( /*line :487:10*/*_Cvar_C_CMP_GT /*line :487:19*/)
	case CompareMaskedEqual:
		return ( /*line :489:10*/*_Cvar_C_CMP_MASKED_EQ /*line :489:26*/)
	default:
		return 0x0
	}
}

func actionFromNative(a  /*line :495:25*/_Ctype_uint32_t /*line :495:35*/) (ScmpAction, error) {
	aTmp := a & 0xFFFF
	switch a & 0xFFFF0000 {
	case ( /*line :498:7*/*_Cvar_C_ACT_KILL /*line :498:18*/):
		return ActKill, nil
	case ( /*line :500:7*/*_Cvar_C_ACT_TRAP /*line :500:18*/):
		return ActTrap, nil
	case ( /*line :502:7*/*_Cvar_C_ACT_ERRNO /*line :502:19*/):
		return ActErrno.SetReturnCode(int16(aTmp)), nil
	case ( /*line :504:7*/*_Cvar_C_ACT_TRACE /*line :504:19*/):
		return ActTrace.SetReturnCode(int16(aTmp)), nil
	case ( /*line :506:7*/*_Cvar_C_ACT_LOG /*line :506:17*/):
		return ActLog, nil
	case ( /*line :508:7*/*_Cvar_C_ACT_ALLOW /*line :508:19*/):
		return ActAllow, nil
	default:
		return 0x0, fmt.Errorf("unrecognized action")
	}
}

// Only use with sanitized actions, no error handling
func (a ScmpAction) toNative()  /*line :516:32*/_Ctype_uint32_t /*line :516:42*/ {
	switch a & 0xFFFF {
	case ActKill:
		return ( /*line :519:10*/*_Cvar_C_ACT_KILL /*line :519:21*/)
	case ActTrap:
		return ( /*line :521:10*/*_Cvar_C_ACT_TRAP /*line :521:21*/)
	case ActErrno:
		return ( /*line :523:10*/*_Cvar_C_ACT_ERRNO /*line :523:22*/) | ( /*line :523:27*/_Ctype_uint32_t /*line :523:37*/(a) >> 16)
	case ActTrace:
		return ( /*line :525:10*/*_Cvar_C_ACT_TRACE /*line :525:22*/) | ( /*line :525:27*/_Ctype_uint32_t /*line :525:37*/(a) >> 16)
	case ActLog:
		return ( /*line :527:10*/*_Cvar_C_ACT_LOG /*line :527:20*/)
	case ActAllow:
		return ( /*line :529:10*/*_Cvar_C_ACT_ALLOW /*line :529:22*/)
	default:
		return 0x0
	}
}

// Internal only, assumes safe attribute
func (a scmpFilterAttr) toNative() uint32 {
	switch a {
	case filterAttrActDefault:
		return uint32(( /*line :539:17*/*_Cvar_C_ATTRIBUTE_DEFAULT /*line :539:37*/))
	case filterAttrActBadArch:
		return uint32(( /*line :541:17*/*_Cvar_C_ATTRIBUTE_BADARCH /*line :541:37*/))
	case filterAttrNNP:
		return uint32(( /*line :543:17*/*_Cvar_C_ATTRIBUTE_NNP /*line :543:33*/))
	case filterAttrTsync:
		return uint32(( /*line :545:17*/*_Cvar_C_ATTRIBUTE_TSYNC /*line :545:35*/))
	default:
		return 0x0
	}
}
